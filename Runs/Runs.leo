<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="0" left="2" height="754" width="1241"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="gcross.20090818114910.1224" str_leo_pos="2"><vh>@chapters</vh></v>
<v t="gcross.20090827130017.1895"><vh>Observable classes</vh>
<v t="gcross.20090827130017.1896"><vh>Base classes</vh>
<v t="gcross.20090827130017.1897"><vh>class Observable</vh>
<v t="gcross.20090827130017.2016"><vh>total_and_write</vh></v>
</v>
<v t="gcross.20090827130017.1899"><vh>class AverageValuesEstimate</vh>
<v t="gcross.20090827130017.2017"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1898"><vh>total_and_write</vh></v>
<v t="gcross.20090827130017.1900"><vh>compute_total</vh></v>
<v t="gcross.20090827130017.2014"><vh>add</vh></v>
</v>
<v t="gcross.20090827130017.1901"><vh>class SingleAverageValueEstimate</vh>
<v t="gcross.20090827130017.1902"><vh>__init__</vh></v>
</v>
<v t="gcross.20090827130017.1903"><vh>class EstimatesAppendedToFile</vh>
<v t="gcross.20090827130017.1904"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1905"><vh>write_out_totals</vh></v>
</v>
<v t="gcross.20090827130017.1906"><vh>class SingleAverageValueEstimateAppendedToFile</vh>
<v t="gcross.20090827130017.1907"><vh>__init__</vh></v>
</v>
<v t="gcross.20090827130017.1908"><vh>class SingleAverageValueAtSliceEstimateAppendedToFile</vh>
<v t="gcross.20090827130017.1909"><vh>__init__</vh></v>
</v>
</v>
<v t="gcross.20090827130017.1910"><vh>Histograms</vh>
<v t="gcross.20090827130017.1911"><vh>class Histogram</vh>
<v t="gcross.20090827130017.1912"><vh>compute_total</vh></v>
<v t="gcross.20090827130017.1913"><vh>write_out_totals</vh></v>
</v>
<v t="gcross.20090827130017.1914"><vh>class PositionDensity1DHistogram</vh>
<v t="gcross.20090827130017.1915"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1916"><vh>update</vh></v>
<v t="gcross.20090827130017.1917"><vh>write_out_totals</vh></v>
</v>
<v t="gcross.20090827130017.1918"><vh>class RadialDensityHistogram</vh>
<v t="gcross.20090827130017.1919"><vh>(fields)</vh></v>
<v t="gcross.20090827130017.1920"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1921"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1922"><vh>class PlaneRadialDensityHistogram</vh>
<v t="gcross.20090827130017.1923"><vh>(fields)</vh></v>
<v t="gcross.20090827130017.1924"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1925"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1926"><vh>class RecipricalRadiusSquaredDensityHistogram</vh>
<v t="gcross.20090827130017.1927"><vh>(fields)</vh></v>
<v t="gcross.20090827130017.1928"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1929"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1930"><vh>class RecipricalPlaneRadiusSquaredDensityHistogram</vh>
<v t="gcross.20090827130017.1931"><vh>(fields)</vh></v>
<v t="gcross.20090827130017.1932"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1933"><vh>update</vh></v>
<v t="gcross.20090827130017.1934"><vh>write_out_totals</vh></v>
</v>
<v t="gcross.20090827130017.1935"><vh>class AngularSeparationDensityHistogram</vh>
<v t="gcross.20090827130017.1936"><vh>(fields)</vh></v>
<v t="gcross.20090827130017.1937"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1938"><vh>update</vh></v>
<v t="gcross.20090827130017.1939"><vh>write_out_totals</vh></v>
</v>
<v t="gcross.20090827130017.1940"><vh>class NeighborAngularSeparationDensityHistogram</vh>
<v t="gcross.20090827130017.1941"><vh>(fields)</vh></v>
<v t="gcross.20090827130017.1942"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1943"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1944"><vh>class AngularVelocityHistogram</vh>
<v t="gcross.20090827130017.1945"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1946"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1947"><vh>class AngularVelocitySquaredHistogram</vh>
<v t="gcross.20090827130017.1948"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1949"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1950"><vh>class RotationQuadraticTermHistogram</vh>
<v t="gcross.20090827130017.1951"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1952"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1953"><vh>class AngularVelocityAndRadiusHistogram</vh>
<v t="gcross.20090827130017.1954"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1955"><vh>update</vh></v>
<v t="gcross.20090827130017.1956"><vh>write_out_totals</vh></v>
</v>
</v>
<v t="gcross.20090827130017.1957"><vh>Energy estimates</vh>
<v t="gcross.20090827130017.1958"><vh>class TotalEnergyEstimate</vh>
<v t="gcross.20090827130017.1959"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1960"><vh>update</vh></v>
<v t="gcross.20090827130017.1961"><vh>write_out</vh></v>
</v>
<v t="gcross.20090827130017.1962"><vh>Slice estimates</vh>
<v t="gcross.20090827130017.1963"><vh>class SliceEnergyEstimate</vh>
<v t="gcross.20090827130017.1964"><vh>__init__</vh></v>
</v>
<v t="gcross.20090827130017.1965"><vh>class EffectivePotentialSliceEnergyEstimate</vh>
<v t="gcross.20090827130017.1966"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1967"><vh>class PhysicalPotentialSliceEnergyEstimate</vh>
<v t="gcross.20090827130017.1968"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1969"><vh>class TotalPotentialSliceEnergyEstimate</vh>
<v t="gcross.20090827130017.1970"><vh>update</vh></v>
</v>
</v>
<v t="gcross.20090827130017.1971"><vh>Path estimates</vh>
<v t="gcross.20090827130017.1972"><vh>class PathEnergyEstimates</vh>
<v t="gcross.20090827130017.1973"><vh>(fields)</vh></v>
<v t="gcross.20090827130017.1974"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1975"><vh>write_out_totals</vh></v>
</v>
<v t="gcross.20090827130017.1976"><vh>class EffectivePotentialPathEnergyEstimates</vh>
<v t="gcross.20090827130017.1977"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1978"><vh>class PhysicalPotentialPathEnergyEstimates</vh>
<v t="gcross.20090827130017.1979"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1980"><vh>class TotalPotentialPathEnergyEstimates</vh>
<v t="gcross.20090827130017.1981"><vh>update</vh></v>
</v>
</v>
</v>
<v t="gcross.20090827130017.1982"><vh>Position estimates</vh>
<v t="gcross.20090827130017.1983"><vh>class AveragePositionEstimate</vh></v>
<v t="gcross.20090827130017.1984"><vh>class AverageAxialCoordinateEstimate</vh>
<v t="gcross.20090827130017.1985"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1986"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1987"><vh>class AverageAxialDistanceEstimate</vh>
<v t="gcross.20090827130017.1988"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1989"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1990"><vh>class AverageRadiusEstimate</vh>
<v t="gcross.20090827130017.1991"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1992"><vh>class AveragePlaneRadiusEstimate</vh>
<v t="gcross.20090827130017.1993"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1994"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.1995"><vh>class AverageRecipricalPlaneRadiusSquaredEstimate</vh>
<v t="gcross.20090827130017.1996"><vh>__init__</vh></v>
<v t="gcross.20090827130017.1997"><vh>update</vh></v>
</v>
</v>
<v t="gcross.20090827130017.1998"><vh>Rotation related estimates</vh>
<v t="gcross.20090827130017.1999"><vh>class AverageAngularVelocityEstimate</vh>
<v t="gcross.20090827130017.2000"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.2001"><vh>class AverageAngularVelocitySquaredEstimate</vh>
<v t="gcross.20090827130017.2002"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.2003"><vh>class AverageRotationQuadraticTermEstimate</vh>
<v t="gcross.20090827130017.2004"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.2008"><vh>class AverageAngularSeparationEstimate</vh>
<v t="gcross.20090827130017.2009"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.2010"><vh>class AverageNeighborAngularSeparationEstimate</vh>
<v t="gcross.20090827130017.2011"><vh>update</vh></v>
</v>
<v t="gcross.20090827130017.2012"><vh>class AverageRotationQuadraticTermEstimate</vh>
<v t="gcross.20090827130017.2013"><vh>update</vh></v>
</v>
</v>
</v>
<v t="gcross.20090827130017.1478"><vh>@path frame-rotation-investigation</vh>
<v t="gcross.20090827130017.1769"><vh>@thin run.py</vh></v>
<v t="gcross.20090827130017.1614"><vh>@thin system.py</vh></v>
</v>
<v t="gcross.20090821120721.1288"><vh>@path angular-momentum-investigation</vh>
<v t="gcross.20090821120721.1289"><vh>@thin run.py</vh></v>
<v t="gcross.20090826111206.1413"><vh>@thin run1.py</vh></v>
<v t="gcross.20090825142352.1348"><vh>@thin run2.py</vh></v>
<v t="gcross.20090825142352.1434"><vh>@thin run3.py</vh></v>
<v t="gcross.20090826111206.1425"><vh>@thin run4.py</vh></v>
<v t="gcross.20090826111206.1451"><vh>@thin run5.py</vh></v>
<v t="gcross.20090826111206.1473"><vh>@thin run6.py</vh></v>
<v t="gcross.20090826111206.1493"><vh>@thin run7.py</vh></v>
<v t="gcross.20090826111206.1513"><vh>@thin run8.py</vh></v>
<v t="gcross.20090826111206.1531"><vh>@thin run9.py</vh></v>
<v t="gcross.20090821120721.1291"><vh>@thin system.py</vh></v>
</v>
<v t="gcross.20090819091604.1233"><vh>@path energy-contours</vh>
<v t="gcross.20090818114910.1235"><vh>@thin run.py</vh></v>
<v t="gcross.20090818114910.1275"><vh>@thin launch-all.py</vh></v>
<v t="gcross.20090819152718.1315"><vh>@thin probe.py</vh></v>
</v>
<v t="gcross.20090819091604.1269"><vh>@path rotation-studies</vh>
<v t="gcross.20090819152718.1279"><vh>@thin run.py</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="gcross.20090818114910.1224"></t>
<t tx="gcross.20090819091604.1233"></t>
<t tx="gcross.20090819091604.1269"></t>
<t tx="gcross.20090821120721.1288"></t>
<t tx="gcross.20090827130017.1478"></t>
<t tx="gcross.20090827130017.1895">@others
</t>
<t tx="gcross.20090827130017.1896"></t>
<t tx="gcross.20090827130017.1897">class Observable(object):
    @others
</t>
<t tx="gcross.20090827130017.1898">def write_out_totals(self,totals_and_errors):
    totals, totals_squared = totals_and_errors
    errors = sqrt(totals_squared-totals**2)
    self.write_out(totals,errors)
</t>
<t tx="gcross.20090827130017.1899">class AverageValuesEstimate(Observable):
    @others
</t>
<t tx="gcross.20090827130017.1900">def compute_total(self):
    total_estimate_and_square = zeros((2,) + self.estimate.shape,dtype='d',order='Fortran')
    comm.Reduce((array(self.estimate,self.estimate_squared),MPI.DOUBLE),(total_estimate_and_square,MPI.DOUBLE))
    total_estimate_and_square /= self.system.total_number_of_observations
    return total_estimate_and_square
</t>
<t tx="gcross.20090827130017.1901">class SingleAverageValueEstimate(AverageValuesEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1902">def __init__(self):
    AverageValuesEstimate.__init__(self,1)
</t>
<t tx="gcross.20090827130017.1903">class EstimatesAppendedToFile(Observable):
    @others
</t>
<t tx="gcross.20090827130017.1904">def __init__(self,filename,label):
    self.filename = filename
    self.label = label
</t>
<t tx="gcross.20090827130017.1905">def write_out(self,total_estimate,total_estimate_error):
    ensure_path_to_file_exists(self.filename)
    with open(self.filename,"a") as f:
        print &gt;&gt; f, self.label,
        for value, error in izip(total_estimate,total_estimate_error):
            print &gt;&gt; f, value, error
        print &gt;&gt; f
</t>
<t tx="gcross.20090827130017.1906">class SingleAverageValueEstimateAppendedToFile(SingleAverageValueEstimate,EstimatesAppendedToFile):
    @others
</t>
<t tx="gcross.20090827130017.1907">def __init__(self,filename,label):
    SingleAverageValueEstimate.__init__(self)
    EstimatesAppendedToFile.__init__(self,filename,label)
</t>
<t tx="gcross.20090827130017.1908">class SingleAverageValueAtSliceEstimateAppendedToFile(SingleAverageValueEstimateAppendedToFile):
    @others
</t>
<t tx="gcross.20090827130017.1909">def __init__(self,slice_number,label,filename):
    SingleAverageValueEstimateAppendedToFile.__init__(self,label,filename)
    self.slice_number = slice_number
</t>
<t tx="gcross.20090827130017.1910"></t>
<t tx="gcross.20090827130017.1911">class Histogram(Observable):
    @others
</t>
<t tx="gcross.20090827130017.1912">def compute_total(self):
    total_histogram = zeros(self.histogram.shape,dtype='i',order='Fortran')
    comm.Reduce((self.histogram,MPI.INT),(total_histogram,MPI.INT))
    return total_histogram
</t>
<t tx="gcross.20090827130017.1913">def write_out_totals(self,histogram):
    ensure_path_to_file_exists(self.filename)
    total_counts = float(sum(histogram))
    bin_width = float(self.right-self.left)/self.number_of_bins
    current = float(self.left)+bin_width/2
    with open(self.filename,"w") as f:
        for count in histogram:
            print &gt;&gt; f, "{0} {1}".format(current,count/total_counts)
            current += bin_width
</t>
<t tx="gcross.20090827130017.1914">class PositionDensity1DHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1915">def __init__(self,slice_number,left,right,number_of_bins,filenames):
    assert len(left) == len(right)
    self.left = left
    self.right = right
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((len(left),number_of_bins),dtype='i',order='Fortran')
    self.filenames = filenames
</t>
<t tx="gcross.20090827130017.1916">def update(self):
    vpi.histograms.accumulate_1d_densities(
        self.system.x[self.slice_number],
        self.left,self.right,
        self.histogram
    )
</t>
<t tx="gcross.20090827130017.1917">def write_out_totals(self,histograms):
    for filename, histogram, left, right in izip(self.filenames,histograms,self.left,self.right):
        ensure_path_to_file_exists(filename)
        with open(filename,"w") as f:
            total_counts = float(sum(histogram))
            bin_width = float(right-left)/self.number_of_bins
            current = float(left)+bin_width/2
            for count in histogram:
                print &gt;&gt; f, "{0} {1}".format(current,count/total_counts)
                current += bin_width
</t>
<t tx="gcross.20090827130017.1918">class RadialDensityHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1919">left = 0
</t>
<t tx="gcross.20090827130017.1920">def __init__(self,slice_number,maximum_radius,number_of_bins,filename):
    self.right = self.maximum_radius = maximum_radius
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((number_of_bins,),dtype='i',order='Fortran')
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1921">def update(self):
    vpi.histograms.accumulate_radial_densities(
        self.system.x[self.slice_number],
        self.maximum_radius,
        self.histogram
    )
</t>
<t tx="gcross.20090827130017.1922">class PlaneRadialDensityHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1923">left = 0
</t>
<t tx="gcross.20090827130017.1924">def __init__(self,slice_number,maximum_radius,number_of_bins,filename):
    self.right = self.maximum_radius = maximum_radius
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((number_of_bins,),dtype='i',order='Fortran')
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1925">def update(self):
    vpi.histograms.accumulate_plane_radial_densities(
        self.system.x[self.slice_number],
        self.maximum_radius,
        self.system.rotation_plane_axis_1,
        self.system.rotation_plane_axis_2,
        self.histogram
    )
</t>
<t tx="gcross.20090827130017.1926">class RecipricalRadiusSquaredDensityHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1927">left = 0
</t>
<t tx="gcross.20090827130017.1928">def __init__(self,slice_number,maximum_value,number_of_bins,filename):
    self.right = self.maximum_value = maximum_value
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((number_of_bins,),dtype='i',order='Fortran')
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1929">def update(self):
    vpi.histograms.accumulate_reciprical_radius_squared_densities(
        self.system.x[self.slice_number],
        self.maximum_value,
        self.histogram
    )
</t>
<t tx="gcross.20090827130017.1930">class RecipricalPlaneRadiusSquaredDensityHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1931">left = 0
</t>
<t tx="gcross.20090827130017.1932">def __init__(self,slice_number,maximum_value,number_of_bins,filename):
    self.right = self.maximum_value = maximum_value
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((number_of_bins,),dtype='i',order='Fortran')
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1933">def update(self):
    vpi.histograms.accumulate_recip_plane_r_sq_densities(
        self.system.x[self.slice_number],
        self.maximum_value,
        self.system.rotation_plane_axis_1,
        self.system.rotation_plane_axis_2,
        self.histogram
    )
</t>
<t tx="gcross.20090827130017.1934">def write_out_totals(self,histogram):
    ensure_path_to_file_exists(self.filename)
    with open(self.filename,"w") as f:
        total_counts = float(sum(histogram))
        bin_width = float(self.maximum_value)/self.number_of_bins
        current = bin_width/2
        for count in self.histogram:
            print &gt;&gt; f, "{0} {1}".format(current,count/total_counts)
            current += bin_width
</t>
<t tx="gcross.20090827130017.1935">class AngularSeparationDensityHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1936">left = 0
right = 2*pi
</t>
<t tx="gcross.20090827130017.1937">def __init__(self,slice_number,number_of_bins,filename):
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((number_of_bins,),dtype='i',order='Fortran')
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1938">def update(self):
    system = self.system
    x = system.x[self.slice_number]
    angles = arctan2(x[:,system.rotation_plane_axis_2],x[:,system.rotation_plane_axis_1])
    vpi.histograms.accumulate_angular_separation_densities(
        angles,
        self.histogram
    )
</t>
<t tx="gcross.20090827130017.1939">def write_out_totals(self,histogram):
    ensure_path_to_file_exists(self.filename)
    with open(self.filename,"w") as f:
        total_counts = float(sum(histogram))
        bin_width = float(2*pi)/self.number_of_bins
        current = bin_width/2
        for count in self.histogram:
            print &gt;&gt; f, "{0} {1}".format(current,count/total_counts)
            current += bin_width
</t>
<t tx="gcross.20090827130017.1940">class NeighborAngularSeparationDensityHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1941">left = 0
right = 2*pi
</t>
<t tx="gcross.20090827130017.1942">def __init__(self,slice_number,number_of_bins,filename):
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((number_of_bins,),dtype='i',order='Fortran')
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1943">def update(self):
    system = self.system
    x = system.x[self.slice_number]
    angles = arctan2(x[:,system.rotation_plane_axis_2],x[:,system.rotation_plane_axis_1])
    vpi.histograms.accumulate_neighbor_angular_separation_densities(
        angles,
        self.histogram
    )
</t>
<t tx="gcross.20090827130017.1944">class AngularVelocityHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1945">def __init__(self,slice_number,left,right,number_of_bins,filename):
    self.left = left
    self.right = right
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((number_of_bins,),dtype='i',order='Fortran')
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1946">def update(self):
    system = self.system
    first_derivatives, _ = vpi.angular_momentum.compute_angular_derivatives(
        system.x[self.slice_number],
        system.rotation_plane_axis_1, system.rotation_plane_axis_2,
        system.number_of_rotating_particles
    )
    vpi.histograms.accumulate(first_derivatives,self.left,self.right,self.histogram)
</t>
<t tx="gcross.20090827130017.1947">class AngularVelocitySquaredHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1948">def __init__(self,slice_number,left,right,number_of_bins,filename):
    self.left = left
    self.right = right
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((number_of_bins,),dtype='i',order='Fortran')
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1949">def update(self):
    system = self.system
    first_derivatives, _ = vpi.angular_momentum.compute_angular_derivatives(
        system.x[self.slice_number],
        system.rotation_plane_axis_1, system.rotation_plane_axis_2,
        system.number_of_rotating_particles
    )
    first_derivatives **= 2
    vpi.histograms.accumulate(first_derivatives,self.left,self.right,self.histogram)
</t>
<t tx="gcross.20090827130017.1950">class RotationQuadraticTermHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1951">def __init__(self,slice_number,left,right,number_of_bins,filename):
    self.left = left
    self.right = right
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((number_of_bins,),dtype='i',order='Fortran')
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1952">def update(self):
    system = self.system
    x = system.x[self.slice_number]
    first_derivatives, _ = vpi.angular_momentum.compute_angular_derivatives(
        x,
        system.rotation_plane_axis_1, system.rotation_plane_axis_2,
        system.number_of_rotating_particles
    )
    term = (first_derivatives ** 2) / (x[:,system.rotation_plane_axis_2-1]**2+x[:,system.rotation_plane_axis_1-1]**2)
    vpi.histograms.accumulate(term,self.left,self.right,self.histogram)
</t>
<t tx="gcross.20090827130017.1953">class AngularVelocityAndRadiusHistogram(Histogram):
    @others
</t>
<t tx="gcross.20090827130017.1954">def __init__(self,slice_number,maximum_angular_velocity,maximum_radius,number_of_bins,filename):
    self.maximum_angular_velocity = maximum_angular_velocity
    self.maximum_radius = maximum_radius
    self.number_of_bins = number_of_bins
    self.slice_number = slice_number
    self.histogram = zeros((number_of_bins,)*2,dtype='i',order='Fortran')
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1955">def update(self):
    system = self.system
    x = system.x[self.slice_number]
    first_derivatives, _ = vpi.angular_momentum.compute_angular_derivatives(
        x,
        system.rotation_plane_axis_1, system.rotation_plane_axis_2,
        system.number_of_rotating_particles
    )
    radii = sqrt(x[system.rotation_plane_axis_2-1]**2+x[system.rotation_plane_axis_1-1]**2)

    i_values = floor(first_derivatives/self.maximum_angular_velocity*self.number_of_bins)
    j_values = floor(radii/self.maximum_radius*self.number_of_bins)
    for (i,j) in izip(i_values,j_values):
        if (i &gt;= 0) and (i &lt; self.number_of_bins) and (j &gt;= 0) and (j &lt; self.number_of_bins):
            self.histogram[i,j] += 1
</t>
<t tx="gcross.20090827130017.1956">def write_out_totals(self,histogram):
    ensure_path_to_file_exists(self.filename)
    total_counts = float(sum(histogram))
    with open(self.filename,"w") as f:
        for i in xrange(self.number_of_bins):
            for j in xrange(self.number_of_bins):
                angular_velocity = (i+0.5)/self.number_of_bins*self.maximum_angular_velocity
                radius = (j+0.5)/self.number_of_bins*self.maximum_radius
                print &gt;&gt; f, "{0} {1} {2}".format(angular_velocity,radius,histogram[i,j]/total_counts)
            print &gt;&gt; f, ""
</t>
<t tx="gcross.20090827130017.1957"></t>
<t tx="gcross.20090827130017.1958">class TotalEnergyEstimate(AverageValuesEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1959">def __init__(self,filename,label):
    self.filename = filename
    self.label = label
    self.estimate = zeros((2,),dtype=double)
</t>
<t tx="gcross.20090827130017.1960">def update(self):
    system = self.system
    estimate = zeros((2,),dtype=double)
    for i, slice_number in enumerate([0,-1]):
        gradient_of_log_trial_fn, laplacian_of_log_trial_fn = system.compute_trial_derivatives(system.x[i],system.xij2[i])
        estimate[i] = \
            vpi.observables.compute_local_energy_estimate(
                system.U[slice_number],
                gradient_of_log_trial_fn, laplacian_of_log_trial_fn,
                system.lambda_,
            )
    self.add(estimate)
</t>
<t tx="gcross.20090827130017.1961">def write_out(self,total_estimates,total_errors):
    ensure_path_to_file_exists(self.filename)
    with open(self.filename,"a") as f:
        print &gt;&gt; f, self.label, mean(total_estimates), sqrt(sum(total_errors**2)/len(total_errors))
</t>
<t tx="gcross.20090827130017.1962"></t>
<t tx="gcross.20090827130017.1963">class SliceEnergyEstimate(SingleAverageValueEstimateAppendedToFile):
    @others
</t>
<t tx="gcross.20090827130017.1964">def __init__(self,slice_number,filename,label):
    SingleAverageValueEstimateAppendedToFile.__init__(self,filename,label)
    self.slice_number = slice_number
</t>
<t tx="gcross.20090827130017.1965">class EffectivePotentialSliceEnergyEstimate(SliceEnergyEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1966">def update(self):
    system = self.system
    U = zeros((1,system.number_of_particles),dtype=double,order='Fortran')
    gradU = zeros((1,system.number_of_particles,system.number_of_dimensions),dtype=double,order='Fortran')
    vpi.angular_momentum.compute_effective_rotational_potential(
        system.x[self.slice_number:self.slice_number+1],system.lambda_,
        system.rotation_plane_axis_1,system.rotation_plane_axis_2,
        system.frame_angular_velocity,system.number_of_rotating_particles,
        U, gradU
    )
    self.add(sum(U))
</t>
<t tx="gcross.20090827130017.1967">class PhysicalPotentialSliceEnergyEstimate(SliceEnergyEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1968">def update(self):
    self.add(sum(dot(self.system.x[self.slice_number]**2,self.system.harmonic_oscillator_coefficients))/2.0)
</t>
<t tx="gcross.20090827130017.1969">class TotalPotentialSliceEnergyEstimate(SliceEnergyEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1970">def update(self):
    self.add(sum(self.system.U[self.slice_number]))
</t>
<t tx="gcross.20090827130017.1971"></t>
<t tx="gcross.20090827130017.1972">class PathEnergyEstimates(AverageValuesEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1973">estimates = 0
</t>
<t tx="gcross.20090827130017.1974">def __init__(self,filename):
    self.filename = filename
</t>
<t tx="gcross.20090827130017.1975">def write_out_totals(self,total_estimates):
    ensure_path_to_file_exists(self.filename)
    center_slice_number = self.system.center_slice_number
    with open(self.filename,"w") as f:
        for slice_number, estimate in enumerate(total_estimates):
            print &gt;&gt; f, center_slice_number-abs(center_slice_number-slice_number), estimate, slice_number
</t>
<t tx="gcross.20090827130017.1976">class EffectivePotentialPathEnergyEstimates(PathEnergyEstimates):
    @others
</t>
<t tx="gcross.20090827130017.1977">def update(self):
    system = self.system
    U = zeros((system.number_of_slices,system.number_of_particles),dtype=double,order='Fortran')
    gradU = zeros((system.number_of_slices,system.number_of_particles,system.number_of_dimensions),dtype=double,order='Fortran')
    vpi.angular_momentum.compute_effective_rotational_potential(
        system.x,system.lambda_,
        system.rotation_plane_axis_1,system.rotation_plane_axis_2,
        system.frame_angular_velocity,system.number_of_rotating_particles,
        U, gradU
    )
    self.estimates += sum(U,axis=-1)
</t>
<t tx="gcross.20090827130017.1978">class PhysicalPotentialPathEnergyEstimates(PathEnergyEstimates):
    @others
</t>
<t tx="gcross.20090827130017.1979">def update(self):
    self.estimates += sum(dot(self.system.x**2,self.system.harmonic_oscillator_coefficients),axis=-1)/2.0
</t>
<t tx="gcross.20090827130017.1980">class TotalPotentialPathEnergyEstimates(PathEnergyEstimates):
    @others
</t>
<t tx="gcross.20090827130017.1981">def update(self):
    self.estimates += sum(self.system.U,axis=-1)
</t>
<t tx="gcross.20090827130017.1982"></t>
<t tx="gcross.20090827130017.1983">class AveragePositionEstimate(SingleAverageValueAtSliceEstimateAppendedToFile):
    pass
</t>
<t tx="gcross.20090827130017.1984">class AverageAxialCoordinateEstimate(AveragePositionEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1985">def __init__(self,axis,slice_number,filename,label):
    AveragePositionEstimate.__init__(self,slice_number,filename,label)
    self.axis = axis
</t>
<t tx="gcross.20090827130017.1986">def update(self):
    self.add(average(self.system.x[self.slice_number,:,self.axis]))
</t>
<t tx="gcross.20090827130017.1987">class AverageAxialDistanceEstimate(AveragePositionEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1988">def __init__(self,axis,slice_number,filename,label):
    AveragePositionEstimate.__init__(self,slice_number,filename,label)
    self.axis = axis
</t>
<t tx="gcross.20090827130017.1989">def update(self):
    self.add(average(abs(self.system.x[self.slice_number,:,self.axis])))
</t>
<t tx="gcross.20090827130017.1990">class AverageRadiusEstimate(AveragePositionEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1991">def update(self):
    self.add(vpi.observables.compute_radius_average(self.system.x[self.slice_number]))
</t>
<t tx="gcross.20090827130017.1992">class AveragePlaneRadiusEstimate(AveragePositionEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1993">def __init__(self,plane_axis_1,plane_axis_2,slice_number,filename,label):
    AveragePositionEstimate.__init__(self,slice_number,filename,label)
    assert plane_axis_1 &gt;= 1
    assert plane_axis_2 &gt;= 1
    assert not (plane_axis_1 == plane_axis_2)
    self.plane_axis_1 = plane_axis_1
    self.plane_axis_2 = plane_axis_2
</t>
<t tx="gcross.20090827130017.1994">def update(self):
    self.add( vpi.observables.compute_plane_radius_average(self.system.x[self.slice_number],self.plane_axis_1,self.plane_axis_2))
</t>
<t tx="gcross.20090827130017.1995">class AverageRecipricalPlaneRadiusSquaredEstimate(AveragePositionEstimate):
    @others
</t>
<t tx="gcross.20090827130017.1996">def __init__(self,plane_axis_1,plane_axis_2,slice_number,filename,label):
    AveragePositionEstimate.__init__(self,slice_number,filename,label)
    assert plane_axis_1 &gt;= 1
    assert plane_axis_2 &gt;= 1
    assert not (plane_axis_1 == plane_axis_2)
    self.plane_axis_1 = plane_axis_1
    self.plane_axis_2 = plane_axis_2
</t>
<t tx="gcross.20090827130017.1997">def update(self):
    self.add(vpi.observables.compute_recip_plane_r_sq_average(self.system.x,self.plane_axis_1,self.plane_axis_2))
</t>
<t tx="gcross.20090827130017.1998"></t>
<t tx="gcross.20090827130017.1999">class AverageAngularVelocityEstimate(SingleAverageValueAtSliceEstimateAppendedToFile):
    @others
</t>
<t tx="gcross.20090827130017.2000">def update(self):
    system = self.system
    first_derivatives, _ = vpi.angular_momentum.compute_angular_derivatives(
        system.x[self.slice_number],
        system.rotation_plane_axis_1, system.rotation_plane_axis_2,
        system.number_of_rotating_particles
    )
    self.add(average(first_derivatives))
</t>
<t tx="gcross.20090827130017.2001">class AverageAngularVelocitySquaredEstimate(SingleAverageValueAtSliceEstimateAppendedToFile):
    @others
</t>
<t tx="gcross.20090827130017.2002">def update(self):
    system = self.system
    first_derivatives, _ = vpi.angular_momentum.compute_angular_derivatives(
        system.x[self.slice_number],
        system.rotation_plane_axis_1, system.rotation_plane_axis_2,
        system.number_of_rotating_particles
    )
    first_derivatives **= 2
    self.add(average(first_derivatives))
</t>
<t tx="gcross.20090827130017.2003">class AverageAngularVelocitySquaredEstimate(SingleAverageValueAtSliceEstimateAppendedToFile):
    @others
</t>
<t tx="gcross.20090827130017.2004">def update(self):
    system = self.system
    first_derivatives, _ = vpi.angular_momentum.compute_angular_derivatives(
        system.x[self.slice_number],
        system.rotation_plane_axis_1, system.rotation_plane_axis_2,
        system.number_of_rotating_particles
    )
    first_derivatives **= 2
    self.add(average(first_derivatives))
</t>
<t tx="gcross.20090827130017.2008">class AverageAngularSeparationEstimate(SingleAverageValueAtSliceEstimateAppendedToFile):
    @others
</t>
<t tx="gcross.20090827130017.2009">def update(self):
    system = self.system
    x = system.x[self.slice_number]
    angles = arctan2(x[:,system.rotation_plane_axis_2],x[:,system.rotation_plane_axis_1])
    self.add(vpi.observables.compute_average_angular_separation(angles))
</t>
<t tx="gcross.20090827130017.2010">class AverageNeighborAngularSeparationEstimate(SingleAverageValueAtSliceEstimateAppendedToFile):
    @others
</t>
<t tx="gcross.20090827130017.2011">def update(self):
    system = self.system
    x = system.x[self.slice_number]
    angles = arctan2(x[:,system.rotation_plane_axis_2],x[:,system.rotation_plane_axis_1])
    self.add(vpi.observables.compute_avg_neighbor_angular_sep(angles))
</t>
<t tx="gcross.20090827130017.2012">class AverageRotationQuadraticTermEstimate(SingleAverageValueAtSliceEstimateAppendedToFile):
    @others
</t>
<t tx="gcross.20090827130017.2013">def update(self):
    system = self.system
    x = system.x[self.slice_number]
    first_derivatives, _ = vpi.angular_momentum.compute_angular_derivatives(
        x,
        system.rotation_plane_axis_1, system.rotation_plane_axis_2,
        system.number_of_rotating_particles
    )
    term = (first_derivatives ** 2) / (x[:,system.rotation_plane_axis_2-1]**2+x[:,system.rotation_plane_axis_1-1]**2)
    self.add(average(term))
</t>
<t tx="gcross.20090827130017.2014">def add(self,estimate):
    self.estimate += estimate
    self.estimate_squared += estimate**2
</t>
<t tx="gcross.20090827130017.2016">def total_and_write(self):
    totals, totals_squared = self.compute_total()
    if my_rank == 0:
        errors = sqrt(totals_squared-totals**2)
        self.write_out_totals(totals,errors)
</t>
<t tx="gcross.20090827130017.2017">def __init__(self,*shape):
    self.estimate = zeros(shape,dtype=double)
    self.estimate_squared = zeros(shape,dtype=double))
</t>
</tnodes>
</leo_file>
